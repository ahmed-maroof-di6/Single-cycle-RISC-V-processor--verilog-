$date
	Wed Sep 20 21:04:25 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_SCP_RISCV_main $end
$var reg 32 ! address [31:0] $end
$var reg 1 " clock $end
$var reg 1 # reset $end
$var reg 1 $ wEn $end
$scope module csp $end
$var wire 32 % address [31:0] $end
$var wire 1 " clock $end
$var wire 1 # reset $end
$var wire 1 $ wEn $end
$var wire 1 & regWrite $end
$var wire 32 ' read_data02 [31:0] $end
$var wire 32 ( read_data01 [31:0] $end
$var wire 32 ) mux_out2 [31:0] $end
$var wire 32 * mux_out1 [31:0] $end
$var wire 1 + memWrite $end
$var wire 1 , memToReg $end
$var wire 1 - memRead $end
$var wire 32 . instruction1 [31:0] $end
$var wire 32 / immGen_out [31:0] $end
$var wire 32 0 dataRead1 [31:0] $end
$var wire 1 1 branch $end
$var wire 32 2 alu_out1 [31:0] $end
$var wire 4 3 alu_opcode1 [3:0] $end
$var wire 32 4 PC [31:0] $end
$var wire 1 5 ALUscr $end
$var wire 2 6 ALUop1 [1:0] $end
$scope module ALUcontrol $end
$var wire 3 7 func3 [2:0] $end
$var wire 7 8 func7 [6:0] $end
$var wire 2 9 ALUop [1:0] $end
$var reg 4 : alu_opcode [3:0] $end
$upscope $end
$scope module DataMem $end
$var wire 1 " clock $end
$var wire 1 # reset $end
$var wire 1 + wEn $end
$var wire 32 ; dataWrite [31:0] $end
$var wire 32 < dataRead [31:0] $end
$var wire 32 = address [31:0] $end
$upscope $end
$scope module Instmem $end
$var wire 1 # reset $end
$var wire 32 > instruction [31:0] $end
$var wire 32 ? address [31:0] $end
$upscope $end
$scope module PC1 $end
$var wire 1 " clock $end
$var wire 1 # reset $end
$var wire 32 @ target_PC [31:0] $end
$var wire 1 1 branch $end
$var wire 32 A PC [31:0] $end
$var reg 32 B PC_reg [31:0] $end
$upscope $end
$scope module Regfile $end
$var wire 1 " clock $end
$var wire 5 C read_reg1 [4:0] $end
$var wire 5 D read_reg2 [4:0] $end
$var wire 1 # reset $end
$var wire 5 E write_reg [4:0] $end
$var wire 32 F write_data [31:0] $end
$var wire 1 & wEn $end
$var wire 32 G read_data2 [31:0] $end
$var wire 32 H read_data1 [31:0] $end
$upscope $end
$scope module alu1 $end
$var wire 4 I alu_opcode [3:0] $end
$var wire 32 J in_a [31:0] $end
$var wire 32 K in_b [31:0] $end
$var reg 32 L alu_out [31:0] $end
$upscope $end
$scope module immi_gen $end
$var wire 32 M inst [31:0] $end
$var reg 32 N GenOut [31:0] $end
$upscope $end
$scope module mainController $end
$var wire 7 O opcode [6:0] $end
$var reg 2 P ALUop [1:0] $end
$var reg 1 5 ALUscr $end
$var reg 1 1 branch $end
$var reg 1 - memRead $end
$var reg 1 , memToReg $end
$var reg 1 + memWrite $end
$var reg 1 & regWrite $end
$upscope $end
$scope module mux1 $end
$var wire 32 Q in0 [31:0] $end
$var wire 32 R in1 [31:0] $end
$var wire 1 5 sel $end
$var wire 32 S mux_out [31:0] $end
$upscope $end
$scope module mux2 $end
$var wire 32 T in0 [31:0] $end
$var wire 32 U in1 [31:0] $end
$var wire 1 , sel $end
$var wire 32 V mux_out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
x5
bx 4
bx 3
bx 2
x1
bx 0
bx /
bx .
x-
x,
x+
bx *
bx )
bx (
bx '
x&
bx %
x$
x#
x"
bx !
$end
#5000
b0 4
b0 ?
b0 A
b0 B
b0 *
b0 K
b0 S
b0 O
b0 7
b0 8
b0 E
b0 D
b0 C
b0 /
b0 N
b0 Q
b0 .
b0 >
b0 M
b0 0
b0 <
b0 T
b0 (
b0 H
b0 J
b0 '
b0 ;
b0 G
b0 R
b1 !
b1 %
b1 @
1$
1#
1"
#10000
0"
#15000
b10111 2
b10111 =
b10111 L
b10111 U
b10 3
b10 :
b10 I
15
0&
0-
1+
01
b0 6
b0 9
b0 P
b100011 O
b110 7
b10000 E
b101 D
b110 C
b10000 /
b10000 N
b10000 Q
b10100110110100000100011 .
b10100110110100000100011 >
b10100110110100000100011 M
b10000 *
b10000 K
b10000 S
bx 0
bx <
bx T
b111 (
b111 H
b111 J
b1101 '
b1101 ;
b1101 G
b1101 R
b10 !
b10 %
b10 @
0#
1"
#20000
0"
#25000
b0 *
b0 K
b0 S
b0 O
b0 7
b0 E
b0 D
b0 C
b0 /
b0 N
b0 Q
b0 )
b0 F
b0 V
b0 .
b0 >
b0 M
b0 2
b0 =
b0 L
b0 U
b0 0
b0 <
b0 T
b0 (
b0 H
b0 J
b0 '
b0 ;
b0 G
b0 R
b100 !
b100 %
b100 @
0$
1#
1"
#30000
0"
#35000
b10000 *
b10000 K
b10000 S
b100011 O
b110 7
b10000 E
b101 D
b110 C
b10000 /
b10000 N
b10000 Q
b0xx1x1 )
b0xx1x1 F
b0xx1x1 V
b10100110110100000100011 .
b10100110110100000100011 >
b10100110110100000100011 M
b10111 2
b10111 =
b10111 L
b10111 U
b1101 0
b1101 <
b1101 T
b111 (
b111 H
b111 J
b1101 '
b1101 ;
b1101 G
b1101 R
b1000 !
b1000 %
b1000 @
1$
0#
1"
#40000
0"
#45000
bx 0
bx <
bx T
b1111 2
b1111 =
b1111 L
b1111 U
b1101 *
b1101 K
b1101 S
b1111 )
b1111 F
b1111 V
b1 3
b1 :
b1 I
05
0,
1&
0+
b10 6
b10 9
b10 P
b110011 O
b10100110110100000110011 .
b10100110110100000110011 >
b10100110110100000110011 M
b100 4
b100 ?
b100 A
b100 B
b1011 !
b1011 %
b1011 @
0$
1"
#50000
0"
#55000
b1111 0
b1111 <
b1111 T
b1100 2
b1100 =
b1100 L
b1100 U
b101 *
b101 K
b101 S
b1111 )
b1111 F
b1111 V
b10 3
b10 :
b10 I
15
1,
1-
b0 6
b0 9
b0 P
b11 O
b101 /
b101 N
b101 Q
b10100110110100000000011 .
b10100110110100000000011 >
b10100110110100000000011 M
b1000 4
b1000 ?
b1000 A
b1000 B
b10000 !
b10000 %
b10000 @
1$
1"
#60000
0"
#65000
b110 3
b110 :
b110 I
05
x,
0&
0-
11
b1 6
b1 9
b1 P
bx )
bx F
bx V
bx 0
bx <
bx T
b11111111111111111111111111111010 2
b11111111111111111111111111111010 =
b11111111111111111111111111111010 L
b11111111111111111111111111111010 U
b1101 *
b1101 K
b1101 S
b1100011 O
b10000 /
b10000 N
b10000 Q
b10100110110100001100011 .
b10100110110100001100011 >
b10100110110100001100011 M
b1100 4
b1100 ?
b1100 A
b1100 B
b10110 !
b10110 %
b10110 @
1"
#70000
0"
#75000
b0 )
b0 F
b0 V
b0 2
b0 =
b0 L
b0 U
b0 *
b0 K
b0 S
b0 O
b0 7
b0 8
b0 E
b0 D
b0 C
b0 /
b0 N
b0 Q
b0 0
b0 <
b0 T
b0 (
b0 H
b0 J
b0 '
b0 ;
b0 G
b0 R
b0 .
b0 >
b0 M
b0 !
b0 %
b0 @
1#
b10110 4
b10110 ?
b10110 A
b10110 B
1"
#80000
0"
